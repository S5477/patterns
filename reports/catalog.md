# Abstract Factory (абстрактная фабрика) 

Предоставляет интерфейс для создания семейств, связанных между собой, или независимых объектов, конкретные классы которых неизвестны.
<br>

# Adapter (адаптер) 

Преобразует интерфейс класса в некоторый другой интерфейс, ожидаемый клиентами. Обеспечивает совместную работу классов, которая была бы невозможна без данного паттерна из-за несовместимости интерфейсов.
<br>

# Bridge (мост) 

Отделяет абстракцию от реализации, благодаря чему появляется возможность независимо изменять то и другое.
<br>

# Builder (строитель) 

Отделяет конструирование сложного объекта от его представления, позволяя использовать один и тот же процесс конструирования для создания различных представлений.
<br>

# Chain of Responsibility (цепочка обязанностей)

Можно избежать жесткой зависимости отправителя запроса от его получателя, при этом запросом начинает обрабатываться один из нескольких объектов. Объекты-получатели связываются в цепочку, и запрос передается по цепочке, пока какой-то объект его не обработает.
<br>

# Command (команда)

Инкапсулирует запрос в виде объекта, позволяя тем самым параметризовывать клиентов типом запроса, устанавливать очередность запросов, протоколировать их и поддерживать отмену выполнения операций.
<br>

# Composite (компоновщик)

Группирует объекты в древовидные структуры для представления иерархий типа «часть-целое». Позволяет клиентам работать с единичными объектами так же, как с группами объектов.
<br>

# Decorator (декоратор)

Динамически возлагает на объект новые функции. Декораторы применяются для расширения имеющейся функциональности и являются гибкой альтернативой порождению подклассов.
<br>

# Facade (фасад) 

Предоставляет унифицированный интерфейс к множеству интерфейсов в некоторой подсистеме. Определяет интерфейс более высокого уровня, облегчающий работу с подсистемой.
<br>

# Factory Method (фабричный метод) 

Определяет интерфейс для создания объектов, при этом выбранный класс инстанцируется подклассами.
<br>

# Flyweight (приспособленец) 

Использует разделение для эффективной поддержки большого числа мелких объектов.
<br>

# Interpreter (интерпретатор) 

Для заданного языка определяет представление его грамматики, а также интерпретатор предложений языка, использующий это представление.
<br>

# Iterator (итератор) 

Дает возможность последовательно обойти все элементы составного объекта, не раскрывая его внутреннего представления.
<br>

# Mediator (посредник)

Определяет объект, в котором инкапсулировано знание о том, как взаимодействуют объекты из некоторого множества. Способствует уменьшению числа связей между объектами, позволяя им работать без явных ссылок друг на друга. Это, в свою очередь, дает возможность независимо изменять схему взаимодействия.
<br>

# Memento (хранитель) 

Позволяет, не нарушая инкапсуляции, получить и сохранить во внешней памяти внутреннее состояние объекта, чтобы позже объект можно было восстановить точно в таком же состоянии.
<br>

# Observer (наблюдатель) 

Определяет между объектами зависимость типа один-ко-многим, так что при изменении состоянии одного объекта все зависящие от него получают извещение и автоматически обновляются.
<br>

# Prototype (прототип) 

Описывает виды создаваемых объектов с помощью прототипа и создает новые объекты "путем его копирования.
<br>

# Proxy (заместитель)

Подменяет другой объект для контроля доступа к нему.
<br>

# Singleton (одиночка) 

Гарантирует, что некоторый класс может иметь только один экземпляр, и предоставляет глобальную точку доступа к нему.
<br>

# State (состояние) 

Позволяет объекту варьировать свое поведение при изменении внутреннего состояния. При этом создается впечатление, что поменялся класс объекта.
<br>

# Strategy (стратегия) 

Определяет семейство алгоритмов, инкапсулируя их все и позволяя подставлять один вместо другого. Можно менять алгоритм независимо от клиента, который им пользуется.
<br>

# Template Method (шаблонный метод) 

Определяет скелет алгоритма, перекладывая ответственность за некоторые его шаги на подклассы. Позволяет подклассам переопределять шаги алгоритма, не меняя его общей структуры.
<br>

# Visitor (посетитель) 

Представляет операцию, которую надо выполнить над элементами объекта. Позволяет определить новую операцию, не меняя классы элементов, к которым он применяется.
<br>
