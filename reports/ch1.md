# ГЛАВА 1

## Введение в паттерны проектирования

### **Програмируй в соответсвии с интерфесом, а не реализацией**
<br>
<br>

**композиция** - объекты уже имеющихся классов просто создаются внутри нового класса. Программист просто использует функциональность уже готового кода
<br>
<br>

**наследование** - новый класс создается как специализация уже существующего класса. Взяв существующий класс за основу, вы добавляете к нему свой код без изменения существующего класса
<br>
<br>

**Делегирование** - «заимствование» методов у объектов других классов. Оно представляет собой альтернативу переопределению методов, используемому полиморфными объектами. В отличие от переопределения, делегирование позволяет определять различное поведение объектов, принадлежащих одному классу. Причем заимствование методов возможно как в пределах класса или иерархии классов, так и у объектов классов других иерархий.
<br>
<br>
<br>

### **Преподчитайте композицию наследованию**

<br>
<br>
<br>

**Агрегация** подразумевает такой тип отношений, в которых дочерняя структура может существовать независимо от родительской. Пример: Person (родительский класс) и Student (дочерний класс). Если Person будет удалён, Student всё равно продолжит существовать.
<br>
<br>
<br>

<br>
<br>
<br>

**Осведомленость** (ассоциация) подразумевает что объекту известно о другом объекте, рсведомленые объекты могут запрашивать друг у друга операции, но не несут ни какой ответсвености друг за друга. Это более слобое отношение, чем агрегирование. Предпологает меньшую связоность.
<br>
<br>
<br>

## Проблема   -->                                           Решение
### При создании объекта, явно указывается класс -->            Абстрактная фабрика, фабричный метод, прототип
### Зависимость от конкретной реализации  -->                   Цепочка обязанностей, Команда
### Зависимость от аппаратной и программной платформы  -->      Абстрактная фабрика, мост
### Зависимость от представления или реализации объетка -->     Абстрактная фабрика, мост, хранитель, заместитель
### Зависимость от алгоритмов  -->                              Мост, итератор, стратегия, шабланный метод, посетитель
### Сильная связанность   -->                                   Абстрактная фабрика, мост,цепочка обязонностей, команда,                                                         Фассад, посредник, наблюдатель
### Расширение функциональности за счет порождения подклассов -->   Мост, цепочка обязанностей, компоновщик, декоратор, наблюдаатель, стратегия
### Неудобства при изменение классов --> Адаптер, декоратор, посититель.

## Приложение
Если вы проектируете приложение - то наивысший приоритет имеют внутреннее повторное использование, <br>
удобство сопровождения и расширяимость. Ослабление связанности.
<br>

## Инструментальные библиотеки
Инструментальная библиотека - это набор взаимосвязанных, повтороно исползуемых классов,<br>
спроектированных с целью предоставления полезной функциональности общего направления. <br><br>
Необходимо избегать предположений и зависимостей.
<br>

## Каркасы приложений
Каркас - набор взаимодействующих классов, состовляющих повторно используемый дизайн для конкретного класса программ. <br>
Повторное использование на данном уровне означает инверсию контроля между приложением и программным обеспечением.<br>
При работе с каркасом вы повторно используете основной код.
<br><br>

## Каркасы vs Шаблоны
### Паттерны абстрактнее каркасов
### Паттерны мельче каркасов
### Паттерны менее специализированы 

# Как выбрать паттерн

## Подумать как паттерны решают проблемы проектирования.
## Почитать назначения паттерна
## Изучить взаимосвязи паттернов
## Анализ схожих по цели паттернов
## Разобраться в причинах перепроектирования
## Как поменяется дизайн

![](https://github.com/S5477/patterns/blob/main/resourses/tab1.2.1.png)
![](https://github.com/S5477/patterns/blob/main/resourses/tab1.2.2.png)

 # Как пользоваться паттерном проектирования

+ Прочитайте описание паттерна, чтобы получить о нем общее представление. Особое внимание обратите на разделы «Применимость» и «Результаты» – убедитесь, что выбранный вами паттерн действительно подходит для решения ваших задач.

+ Вернитесь назад и изучите разделы «Структура», «Участники» и «Отношения». Убедитесь, что понимаете упоминаемые в паттерне классы и объекты и то, как они взаимодействуют друг с другом.

+ Посмотрите на раздел «Пример кода», где приведен конкретный пример использования паттерна в программе. Изучение кода поможет понять, как нужно реализовывать паттерн.

+ Выберите для участников паттерна подходящие имена. Имена участников паттерна обычно слишком абстрактны, чтобы употреблять их непосредственно в коде. Тем не менее бывает полезно включить имя участника как имя в программе. Это помогает сделать паттерн более очевидным при реализации. Например, если вы пользуетесь паттерном стратегия в алгоритме размещения текста, то классы могли бы называться SimpleLayoutStrategy или TeXLayoutStrategy.

+ Определите классы. Объявите их интерфейсы, установите отношения наследования и определите переменные экземпляра, которыми будут представлены данные объекты и ссылки на другие объекты. Выявите имеющиеся в вашем приложении классы, на которые паттерн оказывает влияние, и соответствующим образом модифицируйте их.

+ Определите имена операций, встречающихся в паттерне. Здесь, как и в предыдущем случае, имена обычно зависят от приложения. Руководствуйтесь теми функциями и взаимодействиями, которые ассоциированы с каждой операцией. Кроме того, будьте последовательны при выборе имен. Например, для обозначения фабричного метода можно было бы всюду использовать префикс Create-.

+ Реализуйте операции, которые выполняют обязанности и отвечают за отношения, определенные в паттерне. Советы о том, как это лучше сделать, вы найдете в разделе «Реализация». Поможет и «Пример кода».

![](https://github.com/S5477/patterns/blob/main/resourses/tab1.2.3.png)
